package routing

import (
	"encoding/json"
	"fmt"
	"gongo/entities"
	"gongo/mocks"
	"io"
	"net/http"
	"net/http/httptest"
	"net/url"
	"strings"
	"testing"

	"github.com/gin-gonic/gin"
	//"github.com/prashantv/gostub"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
)

var (
	PRODUCE_ID   string = "code1"
	FAKE_PRODUCE        = entities.Produce{
		ProduceId:   "id",
		ProduceName: "name",
		ProduceCode: "code",
		UnitPrice:   9.80,
	}
	GET_PRODUCE_RESULT = []entities.Produce{
		{
			ProduceId:   "id",
			ProduceName: "name",
			ProduceCode: "code",
			UnitPrice:   9.80,
		},
	}
	GET_ALL_PRODUCE_CONTRACT_RESULT = []interface{}{map[string]interface{}{"ProduceCode": "code", "ProduceId": "id", "ProduceName": "name", "UnitPrice": 9.8}}
	GET_PRODUCE_CONTRACT_RESULT     = map[string]interface{}{"ProduceCode": "code", "ProduceId": "id", "ProduceName": "name", "UnitPrice": 9.8}
	DELETE_PRODUCE_RESULT           = DeleteProduceResult{
		DeletedCount: 64,
		Err:          "",
	}
	ADD_PRODUCE_INPUT = CreateproduceInput{
		Produce: &[]entities.Produce{
			{
				ProduceId:   "id",
				ProduceName: "name",
				ProduceCode: "code",
				UnitPrice:   9.80,
			},
		},
	}
	ADD_PRODUCE_ID_RETURN interface{}   = "IDEN"
	ADD_PRODUCE_OUTPUT    []interface{} = []interface{}{
		ADD_PRODUCE_ID_RETURN,
	}
)

func CreateHttpRecorderAndGinContext() (*gin.Context, *gin.Engine, *httptest.ResponseRecorder) {

	//http context recorder
	w := httptest.NewRecorder()

	//gin context used for testing => will be injected into handler methods for testing
	ginContext, ginEngine := gin.CreateTestContext(w)

	return ginContext, ginEngine, w

}

func TestGetAllProduceRoute(t *testing.T) {

	ginContext, _, w := CreateHttpRecorderAndGinContext()

	//load new IProduceService mock object
	//this object is auto generated by Testify
	//based on the IProduceService interface
	testObj := new(mocks.IProduceService)

	//upon testObj.GetProduce(code1) call, then &GET_PRODUCE_RESULT, nil is returned
	//=> we are mocking the behaviour of the ProduceService entity
	testObj.On("GetProduce").Return(&GET_PRODUCE_RESULT, nil)

	//inject the mock object into the route context
	routeContext := RouteContext{
		ProduceService: testObj,
	}

	//call the Get_ProduceRoute to test accordingly
	//note we inject the test ginContext
	routeContext.Get_ProduceRoute(ginContext)

	//status code should be 200
	assert.Equal(t, 200, w.Code)

	//extract the results of the call from the http recorder
	var got GetProduceResult
	jerr := json.Unmarshal(w.Body.Bytes(), &got)
	if jerr != nil {
		t.Fatal(jerr)
	}

	//define the expected result
	expected := GetProduceResult{
		Produce: GET_ALL_PRODUCE_CONTRACT_RESULT,
		Err:     "",
	}

	//compare expected to actual
	assert.Equal(t, got, expected)

	//assert that the expectations were met
	testObj.AssertExpectations(t)
}

func TestGetProduceByCodeRoute(t *testing.T) {

	ginContext, _, w := CreateHttpRecorderAndGinContext()

	//overload the gin context Params for testing
	//this translates to the path variable code => /produce/:code
	ginContext.Params = []gin.Param{
		{
			Key:   "code",
			Value: PRODUCE_ID,
		},
	}
	//load new IProduceService mock object
	//this object is auto generated by Testify
	//based on the IProduceService interface
	testObj := new(mocks.IProduceService)

	//upon testObj.GetProduce(code1) call, then &GET_PRODUCE_RESULT, nil is returned
	//=> we are mocking the behaviour of the ProduceService entity
	testObj.On("GetProduceByProduceCode", PRODUCE_ID).Return(&FAKE_PRODUCE, nil)

	//inject the mock object into the route context
	routeContext := RouteContext{
		ProduceService: testObj,
	}

	//call the Get_ProduceRoute to test accordingly
	//note we inject the test ginContext
	routeContext.Get_ProduceRoute(ginContext)

	//status code should be 200
	assert.Equal(t, 200, w.Code)

	//extract the results of the call from the http recorder
	var got GetProduceResult
	jerr := json.Unmarshal(w.Body.Bytes(), &got)
	if jerr != nil {
		t.Fatal(jerr)
	}

	//define the expected result
	expected := GetProduceResult{
		Produce: GET_PRODUCE_CONTRACT_RESULT,
		Err:     "",
	}

	//compare expected to actual
	assert.Equal(t, got, expected)

	//assert that the expectations were met
	testObj.AssertExpectations(t)
}

func TestDeleteProduceRoute(t *testing.T) {

	ginContext, _, w := CreateHttpRecorderAndGinContext()

	//overload the gin context Params for testing
	//this translates to the path variable code => /produce/:code
	ginContext.Params = []gin.Param{
		{
			Key:   "code",
			Value: PRODUCE_ID,
		},
	}

	//load new IProduceService mock object
	//this object is auto generated by Testify
	//based on the IProduceService interface
	testObj := new(mocks.IProduceService)

	//upon testObj.DeleteProduce(code1) call, then &deleteCount, nil is returned
	//=> we are mocking the behaviour of the ProduceService entity
	deleteCount := int64(64)
	testObj.On("DeleteProduce", PRODUCE_ID).Return(&deleteCount, nil)

	//inject the mock object into the route context
	routeContext := RouteContext{
		ProduceService: testObj,
	}

	//call the Delete_ProduceRoute to test accordingly
	//note we inject the test ginContext
	routeContext.Delete_ProduceRoute(ginContext)

	//status code should be 200
	assert.Equal(t, 200, w.Code)

	//extract the results of the call from the http recorder
	var got DeleteProduceResult
	err := json.Unmarshal(w.Body.Bytes(), &got)
	if err != nil {
		t.Fatal(err)
	}

	//compare expected to actual
	assert.Equal(t, got, DELETE_PRODUCE_RESULT)

	// assert that the expectations were met
	testObj.AssertExpectations(t)
}

func TestAddProduceRoute(t *testing.T) {

	ginContext, _, w := CreateHttpRecorderAndGinContext()

	//load new IProduceService mock object
	//this object is auto generated by Testify
	//based on the IProduceService interface
	testObj := new(mocks.IProduceService)

	//generate json from ADD_PRODUCE_INPUT
	jsonInput, err := json.Marshal(&ADD_PRODUCE_INPUT)
	if err != nil {
		fmt.Println(err)
		return
	}

	//create fake http request
	req := &http.Request{
		URL:    &url.URL{},
		Header: make(http.Header),
		Body:   io.NopCloser(strings.NewReader(string(jsonInput))), // if you need to test headers
	}

	//inject the request into our test gin context
	ginContext.Request = req

	//upon testObj.AddProduce(anythin) call, then &ADD_PRODUCE_ID_RETURN, nil is returned
	//=> we are mocking the behaviour of the ProduceService entity
	testObj.On("AddProduce", mock.Anything).Return(&ADD_PRODUCE_ID_RETURN, nil)

	//inject the mock object into the route context
	routeContext := RouteContext{
		ProduceService: testObj,
	}

	//call the Add_ProduceRoute to test accordingly
	//note we inject the test ginContext
	routeContext.Add_ProduceRoute(ginContext)

	//status code should be 200
	assert.Equal(t, 200, w.Code)

	//extract the results of the call from the http recorder
	var got CreateProduceResult
	err = json.Unmarshal(w.Body.Bytes(), &got)
	if err != nil {
		t.Fatal(err)
	}

	//compare expected to actual
	assert.Equal(t, *got.ProduceAdded, ADD_PRODUCE_OUTPUT)

	// assert that the expectations were met
	testObj.AssertExpectations(t)

}
